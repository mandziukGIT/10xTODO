create type task_source as enum (
  'ai_full',    -- generated by ai (unedited)
  'ai_edited',  -- generated and then edited by user
  'manual'      -- manually added by user
);

create table if not exists tasks (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  generation_id uuid references generation_process(id) on delete set null,
  parent_task_id uuid references tasks(id) on delete cascade,
  position int not null check (position > 0),
  source task_source not null,
  title varchar(255) not null,
  description text,
  created_at timestamptz not null default now(),
  completed boolean not null default false,
  completed_at timestamptz
);

create index on tasks(user_id);
create index on tasks(generation_id);

alter table tasks enable row level security;

create policy tasks_select on tasks
  for select using (user_id = auth.uid());
create policy tasks_insert on tasks
  for insert with check (user_id = auth.uid());
create policy tasks_update on tasks
  for update using (user_id = auth.uid()) with check (user_id = auth.uid());
create policy tasks_delete on tasks
  for delete using (user_id = auth.uid());

-- trigger: limit number of subtasks (before insert)

-- function to enforce subtask limits
create or replace function enforce_subtask_limits() returns trigger as $$
declare
  root_parent uuid;
  level2_count int;
begin
  if new.parent_task_id is not null then
    -- determine if parent is root or child
    select parent_task_id into root_parent from tasks where id = new.parent_task_id;
    if root_parent is null then
      -- parent is root: count its children
      select count(*) into level2_count
        from tasks
        where parent_task_id = new.parent_task_id;
      if level2_count >= 10 then
        raise exception 'cannot have more than 10 second-level subtasks';
      end if;
    else
      -- parent is already level 2: disallow deeper nesting
      raise exception 'cannot nest tasks more than 2 levels';
    end if;
  end if;
  return new;
end;
$$ language plpgsql security definer;

-- attach before insert trigger
create trigger trigger_enforce_subtask_limits
  before insert on tasks
  for each row execute function enforce_subtask_limits();

-- trigger: cascade completion (after update)

-- function to mark subtasks complete when parent completed
create or replace function cascade_task_completion() returns trigger as $$
begin
  if new.completed and not old.completed then
    -- set all direct children completed
    update tasks set completed = true, completed_at = now()
      where parent_task_id = new.id
        and completed = false;
    -- set grandchildren completed
    update tasks set completed = true, completed_at = now()
      where parent_task_id in (
        select id from tasks where parent_task_id = new.id
      ) and completed = false;
  end if;
  return new;
end;
$$ language plpgsql security definer;

-- attach after update trigger
create trigger trigger_cascade_task_completion
  after update of completed on tasks
  for each row execute function cascade_task_completion();